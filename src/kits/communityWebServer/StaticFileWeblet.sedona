//
// Copyright (c) 2018
// Licensed under the Academic Free License version 3.0
//
// History:
//   30 Jun 18  Vincent Wang  Static File Weblet
//

** 
** StaticFileWeblet provides the ability to serve static files(html, css, js,
** images etc) through http, so that user can use sedona as a minimal web
** server and host a static web app just in sedona, without any outside
** dependency. 
** to save space on sedona, gzipped file is supported and I recommend to use it
** since that will be more efficient(less bytes to be loaded and transferred)
** 
class StaticFileWeblet extends Weblet
{
////////////////////////////////////////////////////////////////
// Weblet Registration
////////////////////////////////////////////////////////////////

  static void _sInit()
  {
    instance.register()
  }
  static internal inline StaticFileWeblet instance

////////////////////////////////////////////////////////////////
// Weblet
////////////////////////////////////////////////////////////////

  ** 
  ** all static files to be served must be put under 'statics' folder
  ** and the url will start with 'statics', too 
  override Str prefix() { return "statics" }

  override Str description() { return "Sedona Static File Weblet" }

  **
  ** since we only serve static file here, so only 'GET' method is supported
  ** 
  override void service(WebReq req, WebRes res)
  {
    Str method = req.method;
    if (method.equals("GET")) 
      get(req, res)
    else {
      res.writeStatus(HttpCode.methodNotAllowed)
      res.writeHeader("Allow", "GET")
    }
  }

  ** 
  ** handle 'GET' request, try to find the static file and return it 
  **
  override void get(WebReq req, WebRes res)
  {
    reset()

    prepareFile(req)

    if (isDir(filePath)) {
      tryAppendIndex(filePath)
    }

    serveFile(res)
  }

  internal void reset() 
  {
    filePath.set(0, 0)
  }

  internal void serveFile(WebRes res) 
  {
    if (file.name==null) {
      res.writeStatus(HttpCode.notFound).finishHeaders()
      return
    }

    if (!file.exists()) {
      //try gzipped content
      int index = file.name.length()
      if (index+4 < pathStrLen) {
        file.name.set(index++, '.')
        file.name.set(index++, 'g')
        file.name.set(index++, 'z')
        file.name.set(index, 0)
      }

      if (!file.exists()) {
        res.writeStatus(HttpCode.notFound).finishHeaders()
        return
      }
    }

    if (!file.open("r")) {
      res.writeStatus(HttpCode.internalError).finishHeaders()
      return
    }

    App.log.message("Serving File: " + file.name);
    res.writeStatusOk()

    //write headers
    if (endsWith(file.name, ".gz", 0))
      res.writeHeader("Content-Encoding", "gzip");

    res.writeContentType(getContentType(file.name))
      .writeHeader("Cache-Control", "max-age=604800")
      .writeHeader("Server", "Sedona Web Server")
      .writeHeader("Content-Length", Sys.intStr(file.size()))
      .finishHeaders()

    file.seek(0)
    while(true) {
      int readed = file.in.readBytes(readBuf, 0, bufLen)
      if (readed <= 0)
        break

      res.writeBytes(readBuf, 0, readed)
    }

    file.close()
  }

  bool isDir(Str fileName) {
    if (endsWith(fileName, "/", 0))
      return true

    int len = fileName.length()
    //check if there is a file extention 
    for(int i=len-3; i>0 && i>len-6; --i) {
      if (fileName.get(i) != '.')
        continue

      return false
    }

    return true
  }

  **
  ** if the URL ends with '/', then append 'index.html' and try serve it 
  **
  bool tryAppendIndex(Str fileName) {
    int len = fileName.length()
    if (len <= 0)
      return false

    //try to append index.html to path end 
    byte[] buf = fileName.toBytes()
    if (len+11 < pathStrLen) {
      if (!endsWith(fileName, "/", 0))
        buf[len++] = '/'
      buf[len++] = 'i'
      buf[len++] = 'n'
      buf[len++] = 'd'
      buf[len++] = 'e'
      buf[len++] = 'x'
      buf[len++] = '.'
      buf[len++] = 'h'
      buf[len++] = 't'
      buf[len++] = 'm'
      buf[len++] = 'l'
      buf[len++] = 0 
      return true
    }

    return false
  }

  static public bool endsWith(Str str, Str suffix, int endOffset) {
    return suffix.equalsRegion(str, str.length()-suffix.length()-endOffset, str.length()-endOffset)
  } 

  internal Str getContentType(Str fileName) 
  {
    int endOffset = 0
    if (endsWith(fileName, ".gz", 0))
      endOffset = 3

    if (endsWith(fileName, ".html", endOffset) || endsWith(fileName, ".htm", endOffset))  
      return "text/html"
    else if (endsWith(fileName, ".css", endOffset))
      return "text/css"
    else if (endsWith(fileName, ".txt", endOffset))
      return "text/plain"
    else if (endsWith(fileName, ".js", endOffset))
      return "application/javascript"
    else if (endsWith(fileName, ".json", endOffset))
      return "application/json"
    else if (endsWith(fileName, ".xml", endOffset))
      return "application/xml"
    else if (endsWith(fileName, ".pdf", endOffset))
      return "application/pdf"
    else if (endsWith(fileName, ".jpg", endOffset))
      return "image/jpeg"
    else if (endsWith(fileName, ".png", endOffset))
      return "image/png"
    else
      return "text/plain"
  }

  internal void prepareFile(WebReq req) 
  {
    if (req.path.size < 1)
      return
    else {
      //TODO: process path to avoid security issues
      filePath.copyFromStr(".", pathStrLen);
      int index = filePath.length()
      byte[] fileBuf = filePath.toBytes()
      for(int i=0; i<req.path.size && index<pathStrLen-2; ++i) {
        byte[] nameBuf = req.path.names[i].toBytes() 
        fileBuf[index++] = '/'
        for(int j=0; j<req.path.names[i].length() && index<pathStrLen-2; ++j) {
          fileBuf[index++] = nameBuf[j]
        }
      }
      fileBuf[index] = 0
    }

    file.name = filePath
  }

////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////

  public void index(WebReq req, WebRes res)
  {
    res.html();
    res.w("<h1>Hello World!</h1>\n");
    res.htmlEnd();
  }

////////////////////////////////////////////////////////////////
// Fields
////////////////////////////////////////////////////////////////
  define int bufLen = 1024
  define int pathStrLen = 256

  private inline byte[bufLen] readBuf
  internal inline Str(pathStrLen) filePath  // buffer for file's path
  internal inline File file
}

